<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dev's Infinite Universe</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #info {
            position: absolute; top: 10px; left: 10px; color: #00ffcc;
            font-family: 'Courier New', monospace; pointer-events: none;
            background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ffcc;
        }
    </style>
</head>
<body>

    <div id="info">
        PROJECT: MANDELBROT (GLSL)<br>
        STATUS: RENDERING INFINITY<br>
        ACTION: PINCH / SCROLL TO ZOOM
    </div>
    <canvas id="glcanvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 u_resolution;
        uniform vec2 u_zoomCenter;
        uniform float u_zoomSize;
        uniform int u_maxIterations;

        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            
            // સ્ક્રીન રેશિયો એડજસ્ટમેન્ટ
            float ratio = u_resolution.x / u_resolution.y;
            
            // કો-ઓર્ડિનેટ મેપિંગ
            vec2 c = u_zoomCenter + (uv - 0.5) * vec2(ratio, 1.0) * u_zoomSize;
            
            vec2 z = vec2(0.0);
            int iterations = 0;
            
            // મેન્ડલબ્રોટ ફોર્મ્યુલા: Z = Z² + C
            // આ લૂપ નક્કી કરે છે કે પોઈન્ટ અનંત તરફ જાય છે કે નહીં
            for (int i = 0; i < 500; i++) {
                if (i >= u_maxIterations) break;
                
                // Complex Number Square: (x+yi)² = (x²-y²) + (2xy)i
                float x = (z.x * z.x - z.y * z.y) + c.x;
                float y = (2.0 * z.x * z.y) + c.y;
                
                if ((x * x + y * y) > 4.0) break; // Escape radius
                
                z.x = x;
                z.y = y;
                iterations++;
            }

            // કલરિંગ (સાઈકેડેલિક ઈફેક્ટ)
            if (iterations == u_maxIterations) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // અંદરનો ભાગ કાળો (શાંતિ)
            } else {
                float t = float(iterations) / float(u_maxIterations);
                
                // કલર પેલેટ (R, G, B) - ગણિત આધારિત
                float r = 0.5 + 0.5 * cos(3.0 + t * 10.0);
                float g = 0.5 + 0.5 * cos(3.5 + t * 10.0);
                float b = 0.5 + 0.5 * cos(4.0 + t * 10.0);
                
                gl_FragColor = vec4(r, g, b, 1.0);
            }
        }
    </script>

    <script>
        const canvas = document.getElementById("glcanvas");
        const gl = canvas.getContext("webgl");

        if (!gl) {
            alert("WebGL not supported");
        }

        // શેડર કમ્પાઈલ ફંક્શન
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vsSource = document.getElementById("vs").text;
        const fsSource = document.getElementById("fs").text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // બફર સેટઅપ (આખી સ્ક્રીન કવર કરવા માટે બે ત્રિકોણ)
        const positionLocation = gl.getAttribLocation(program, "position");
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1.0, -1.0,
             1.0, -1.0,
            -1.0,  1.0,
            -1.0,  1.0,
             1.0, -1.0,
             1.0,  1.0]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // યુનિફોર્મ્સ (Variables sending to GPU)
        const u_resolution = gl.getUniformLocation(program, "u_resolution");
        const u_zoomCenter = gl.getUniformLocation(program, "u_zoomCenter");
        const u_zoomSize = gl.getUniformLocation(program, "u_zoomSize");
        const u_maxIterations = gl.getUniformLocation(program, "u_maxIterations");

        // પ્રારંભિક સ્થિતિ
        let zoomCenter = { x: -0.75, y: 0.0 };
        let targetZoomCenter = { x: -0.75, y: 0.0 };
        let zoomSize = 3.0;
        let targetZoomSize = 3.0;
        let maxIterations = 200;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // રેન્ડર લૂપ
        function render() {
            // સ્મૂધ એનિમેશન (Lerp)
            zoomSize += (targetZoomSize - zoomSize) * 0.1;
            zoomCenter.x += (targetZoomCenter.x - zoomCenter.x) * 0.1;
            zoomCenter.y += (targetZoomCenter.y - zoomCenter.y) * 0.1;

            // જેમ જેમ ઝૂમ થાય તેમ ડિટેલ (Iterations) વધારવી પડે
            // જેથી પિક્સેલ ફાટે નહીં
            maxIterations = Math.floor(200 + Math.log(3.0 / zoomSize) * 50);

            gl.uniform2f(u_resolution, canvas.width, canvas.height);
            gl.uniform2f(u_zoomCenter, zoomCenter.x, zoomCenter.y);
            gl.uniform1f(u_zoomSize, zoomSize);
            gl.uniform1i(u_maxIterations, maxIterations);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }
        render();

        // --- કંટ્રોલ્સ (Touch & Mouse) ---
        
        // ઝૂમ ફંક્શન
        function handleZoom(x, y, delta) {
            const zoomFactor = delta > 0 ? 1.1 : 0.9;
            
            // માઉસ પોઝિશન મુજબ ઝૂમ કરવું (ગણિત)
            const ratio = canvas.width / canvas.height;
            const uvX = (x / canvas.width - 0.5) * ratio * zoomSize;
            const uvY = (1.0 - y / canvas.height - 0.5) * zoomSize; // WebGL Y is inverted
            
            targetZoomCenter.x += uvX * (1 - 1/zoomFactor);
            targetZoomCenter.y += uvY * (1 - 1/zoomFactor);
            
            targetZoomSize *= zoomFactor;
        }

        // માઉસ ઇવેન્ટ્સ
        window.addEventListener('wheel', (e) => {
            handleZoom(e.clientX, e.clientY, Math.sign(e.deltaY));
        });

        // ટચ ઇવેન્ટ્સ (Pinch to Zoom)
        let initialPinchDistance = null;
        
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                initialPinchDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && initialPinchDistance) {
                const currentDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                
                // સેન્ટર પોઈન્ટ શોધો
                const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                const delta = initialPinchDistance > currentDistance ? 1 : -1;
                handleZoom(cx, cy, delta * 0.5); // ધીમું ઝૂમ
                
                initialPinchDistance = currentDistance;
            }
            e.preventDefault(); // સ્ક્રોલ રોકવા
        }, { passive: false });

    </script>
</body>
</html>
