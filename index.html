<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vidushi Pulse Monitor</title>
    <style>
        body { margin: 0; background: #111; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        
        h2 { color: #ff3333; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 10px; }
        
        /* ркзркмркХркдрлБркВ рк╣рлГркжркп */
        #heart-icon {
            font-size: 80px; color: #333; margin: 20px;
            transition: transform 0.1s;
        }
        .beat { color: #ff0000 !important; transform: scale(1.2); }

        /* ркЧрлНрк░рк╛ркл */
        canvas {
            background: #000;
            border: 1px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.2);
            width: 90%; max-width: 400px; height: 200px;
        }

        #bpm-display { font-size: 60px; font-weight: bold; margin: 10px; font-family: monospace; }
        #status { color: #aaa; font-size: 14px; margin-top: 5px; text-align: center; max-width: 300px;}

        /* рк╡рк┐ркбрлАркпрлЛ ркЫрлБрккрк╛ркпрлЗрк▓рлЛ рк░рк╣рлЗрк╢рлЗ */
        video { position: absolute; opacity: 0; pointer-events: none; width: 1px; height: 1px; }

        button {
            margin-top: 20px; padding: 10px 20px;
            background: #ff3333; color: white; border: none; border-radius: 5px;
            font-size: 16px; cursor: pointer;
        }
    </style>
</head>
<body>

    <h2>Vidushi Pulse тЭдя╕П</h2>
    
    <div id="heart-icon">тЩе</div>
    <div id="bpm-display">--</div>
    <div style="color: #ff3333; font-size: 12px;">BPM</div>

    <canvas id="waveCanvas"></canvas>
    
    <p id="status">ркХрлЗркорлЗрк░рк╛ рк╢рк░рлВ ркХрк░рк╡рк╛ ркорк╛ркЯрлЗ ркмркЯрки ркжркмрк╛рк╡рлЛ.</p>
    <button id="startBtn">Start Monitor</button>

    <video id="video" playsinline></video>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');
        const bpmDisplay = document.getElementById('bpm-display');
        const status = document.getElementById('status');
        const heartIcon = document.getElementById('heart-icon');
        const startBtn = document.getElementById('startBtn');

        let isRunning = false;
        let signalBuffer = []; // ркЧрлНрк░рк╛ркл ркорк╛ркЯрлЗ ркбрлЗркЯрк╛
        const maxBuffer = 100;
        
        // BPM ркЧркгркдрк░рлА ркорк╛ркЯрлЗ
        let peaks = [];
        let lastPeakTime = 0;

        // ркЯрлЛрк░рлНркЪ (Flash) ркЪрк╛рк▓рлБ ркХрк░рк╡рк╛ркирлЛ рккрлНрк░ркпрк╛рк╕
        async function enableTorch(track) {
            try {
                await track.applyConstraints({ advanced: [{ torch: true }] });
            } catch (err) {
                console.log("Torch not supported/allowed", err);
                status.innerText += " (Flash ркЪрк╛рк▓рлБ ркиркерлА ркеркИ рк╢ркХрлНркпрлЛ, ркорк╣рлЗрк░ркмрк╛ркирлА ркХрк░рлАркирлЗ рк▓рк╛ркИркЯ рк╕рк╛ркорлЗ ркЖркВркЧрк│рлА рк░рк╛ркЦрлЛ)";
            }
        }

        startBtn.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                video.srcObject = stream;
                await video.play();

                // ркХрлЗркорлЗрк░рк╛ркирлА рк╕рлЗркЯрк┐ркВркЧрлНрк╕ркорк╛ркВркерлА ркЯрлЛрк░рлНркЪ ркЪрк╛рк▓рлБ ркХрк░рк╡рк╛ркирлЛ рккрлНрк░ркпрк╛рк╕
                const track = stream.getVideoTracks()[0];
                enableTorch(track);

                status.innerText = "ЁЯТб рк╣рк╡рлЗ рккрк╛ркЫрк│ркирк╛ ркХрлЗркорлЗрк░рк╛ рккрк░ ркЖркВркЧрк│рлА ркорлВркХрлЛ (Flash рквркВркХрк╛ркИ ркЬрк╛ркп ркдрлЗрко).";
                startBtn.style.display = 'none';
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                isRunning = true;
                processFrame();

            } catch (err) {
                status.innerText = "Error: Camera Access Denied.";
            }
        });

        function processFrame() {
            if (!isRunning) return;

            // рк╡рк┐ркбрлАркпрлЛркорк╛ркВркерлА ркбрлЗркЯрк╛ рк╡рк╛ркВркЪрк╡рк╛ ркорк╛ркЯрлЗ ркПркХ ркирк╛ркирлБркВ ркХрлЗркирлНрк╡рк╛рк╕
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = 50; // ркирк╛ркирлА рк╕рк╛ркИркЭ ркЬрлЗркерлА рккрлНрк░рлЛрк╕рлЗрк╕рк┐ркВркЧ рклрк╛рк╕рлНркЯ ркерк╛ркп
            tempCanvas.height = 50;
            
            tempCtx.drawImage(video, 0, 0, 50, 50);
            const frame = tempCtx.getImageData(0, 0, 50, 50);
            const data = frame.data;

            // рк╕рк░рлЗрк░рк╛рк╢ рк▓рк╛рк▓ рк░ркВркЧ (Red Brightness) рк╢рлЛркзрлЛ
            let totalRed = 0;
            for (let i = 0; i < data.length; i += 4) {
                totalRed += data[i]; // Red channel
            }
            const avgRed = totalRed / (data.length / 4);

            // ркЬрлЛ ркЖркВркЧрк│рлА ркорлВркХрлА рк╣рлЛркп, ркдрлЛ рк▓рк╛рк▓ ркХрк▓рк░ ркмрк╣рлБ рк╡ркзрк╛рк░рлЗ рк╣рк╢рлЗ
            if (avgRed < 50) {
                status.innerText = "тЪая╕П ркЖркВркЧрк│рлА ркмрк░рк╛ркмрк░ ркорлВркХрлЛ (Flash ркжрлЗркЦрк╛рк╡рлА ркЬрлЛркИркП)";
                status.style.color = "orange";
                bpmDisplay.innerText = "--";
            } else {
                status.innerText = "Detecting Pulse... (рк╕рлНркерк┐рк░ рк░рк╣рлЛ)";
                status.style.color = "#aaa";
                
                // рк╕рк┐ркЧрлНркирк▓ ркмрклрк░ркорк╛ркВ ркбрлЗркЯрк╛ ркЙркорлЗрк░рлЛ
                signalBuffer.push(avgRed);
                if (signalBuffer.length > maxBuffer) signalBuffer.shift();

                drawGraph();
                calculateBPM(avgRed);
            }

            requestAnimationFrame(processFrame);
        }

        function calculateBPM(value) {
            const now = Date.now();
            
            // Peak Detection (рк╕рк░рк│ рк▓рлЛркЬрк┐ркХ)
            // ркЬрлЛ ркЕркдрлНркпрк╛рк░ркирлА рк╡рлЗрк▓рлНркпрлБ рк╕рк░рлЗрк░рк╛рк╢ ркХрк░ркдрк╛ркВ рк╡ркзрк╛рк░рлЗ рк╣рлЛркп ркдрлЛ ркзркмркХрк╛рк░рлЛ ркЧркгрк╡рлЛ
            
            // ркмрклрк░ркирлА рк╕рк░рлЗрк░рк╛рк╢ ркХрк╛ркврлЛ (Baseline)
            const sum = signalBuffer.reduce((a, b) => a + b, 0);
            const avg = sum / signalBuffer.length;

            // Threshold (рк╕рк░рлЗрк░рк╛рк╢ ркХрк░ркдрк╛ ркерлЛркбрлБркВ ркЙрккрк░)
            if (value > avg + 2 && (now - lastPeakTime > 300)) { // 300ms min delay (to avoid double count)
                lastPeakTime = now;
                
                // Visual Effect
                heartIcon.classList.add('beat');
                setTimeout(() => heartIcon.classList.remove('beat'), 100);

                // BPM ркЧркгркдрк░рлА (60000 ms / time diff)
                peaks.push(now);
                if (peaks.length > 5) peaks.shift(); // ркЫрлЗрк▓рлНрк▓рк╛ 5 ркзркмркХрк╛рк░рк╛ркирлЛ ркПрк╡рк░рлЗркЬ

                if (peaks.length > 1) {
                    let totalDiff = 0;
                    for (let i = 1; i < peaks.length; i++) {
                        totalDiff += (peaks[i] - peaks[i-1]);
                    }
                    let avgDiff = totalDiff / (peaks.length - 1);
                    let bpm = Math.round(60000 / avgDiff);
                    
                    // рк╡рк╛рк╕рлНркдрк╡рк┐ркХ рк░рлЗркирлНркЬ (40-160) рк╣рлЛркп ркдрлЛ ркЬ ркмркдрк╛рк╡рлЛ
                    if (bpm > 40 && bpm < 180) {
                        bpmDisplay.innerText = bpm;
                    }
                }
            }
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.strokeStyle = '#ff3333';
            ctx.lineWidth = 2;

            const sliceWidth = canvas.width / maxBuffer;
            let x = 0;

            // ркЧрлНрк░рк╛рклркирлЗ ркирлЛрк░рлНркорк▓рк╛ркИркЭ ркХрк░рлЛ (ркЬрлЗркерлА ркдрлЗ ркХрлЗркирлНрк╡рк╛рк╕ркирлА рк╡ркЪрлНркЪрлЗ ркжрлЗркЦрк╛ркп)
            const min = Math.min(...signalBuffer);
            const max = Math.max(...signalBuffer);
            const range = max - min || 1;

            for (let i = 0; i < signalBuffer.length; i++) {
                const y = canvas.height - ((signalBuffer[i] - min) / range) * canvas.height;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);

                x += sliceWidth;
            }
            ctx.stroke();
        }
    </script>
</body>
</html>
